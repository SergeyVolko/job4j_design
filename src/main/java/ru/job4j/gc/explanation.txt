1. Объект User состоит из двух полей
int age
String name.
Заголовок объекта - 8 байт
Поле int - 4 байта
Поле String name:
        Заголовок объекта - 8 байт
        Поле ссылка byte[] value - 4 байта
        Поле byte coder - 1 байт
        Поле int hash - 4 байта
        Поле boolean hashIsZero - 1 байт
        Выравнивание - 6 байт
        Итого: 24 байта
            Плюс к этому массив byte[] value:
            Заголовок - 8 байт + 4 байта на длинну массива для (name Alex) = 12 байт
            Примитивы byte - 4 * 1 = 4 (Массив заполняется 4 байтами)
            Итого: 16
Всего String для name Alex: 24 + 16 = 40 байт
Выравнивание: 4 байта
ИТОГО память под new User("Alex", i): 56 байт

2 Программа работает следующим образом.
Перед выполнением программы мы определили -Xmx4m -Xms4m-это первоначальный и максимальный размер кучи
равные 4 мегабайт.

В процессе создания объектов new User("Alex", i)
заполняется область edem. Как только переполняется область edem
происходит минорная сборка мусора (Minor GC) и вызывается метод finalize(), который покажет
нам удаленные объекты.

Объекты создаваемые области eden выживать не будут, т.к. на них нет ссылок,
сдедовательно области s0 и s1 будут
оставться пустыми. Тогда можно сделать вывод, что определяющим фактором вызова сборки мусора будет
переполнение области eden.

Для количества создаваемых объектов равных 20000 сборка мусора не всегда происходит.
Следовательно, можно сделать предположение, что память выделяемая для области eden при каждом
запуске программы разная.